<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Wheel Spinner</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the spinner's aesthetics */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        /* Canvas container to hold the wheel and ensure centering */
        #wheelContainer {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            max-width: 500px;
            width: 100%;
            aspect-ratio: 1 / 1; /* Keep it square */
            margin-bottom: 24px;
        }

        #wheelCanvas {
            border-radius: 9999px; /* Fully rounded */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05);
            width: 100%;
            height: 100%;
        }

        /* The pointer/indicator - AT THE BOTTOM (6 o'clock) */
        #pointer {
            position: absolute;
            bottom: 0; 
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid #ef4444; 
            z-index: 10;
        }

        /* Result Box styling */
        #resultBox {
            min-height: 56px;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="w-full max-w-4xl bg-white p-6 md:p-10 rounded-xl shadow-2xl border border-gray-100">

        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Random Selection Spinner</h1>
        <p class="text-center text-gray-500 mb-8">Enter your list (names, topics, numbers), one item per line (up to 50 items), and click 'Spin'!</p>

        <!-- Main Content Area: Wheel and Controls -->
        <div class="flex flex-col lg:flex-row gap-8">

            <!-- Wheel Area -->
            <div class="lg:w-1/2 flex flex-col items-center">
                <div id="wheelContainer">
                    <canvas id="wheelCanvas" width="500" height="500"></canvas>
                    <div id="pointer"></div>
                </div>

                <!-- Spin Button and Result -->
                <button id="spinButton"
                        class="w-full max-w-xs bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition duration-150 ease-in-out shadow-lg transform hover:scale-[1.02] active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed text-lg">
                    Spin the Wheel!
                </button>

                <!-- Result Message -->
                <div class="mt-8 w-full max-w-xs text-center">
                    <p class="text-lg font-semibold text-gray-600 mb-2">Winner:</p>
                    <div id="resultBox" class="bg-indigo-50 text-indigo-700 font-extrabold text-2xl p-3 rounded-lg shadow-inner flex items-center justify-center transition duration-300">
                        Ready to Spin
                    </div>
                </div>

                <!-- Alert/Error Message Box -->
                <div id="messageBox" class="mt-4 w-full max-w-xs p-3 bg-red-100 text-red-700 rounded-lg hidden"></div>
            </div>

            <!-- Input and Configuration Area -->
            <div class="lg:w-1/2">
                <label for="inputList" class="block text-sm font-medium text-gray-700 mb-2">
                    Enter Items (One per line, Max 50):
                </label>
                
                <div class="flex gap-2 items-start">
                    <!-- Item Input (Textarea) -->
                    <textarea id="inputList" rows="10"
                              class="w-2/3 p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-gray-800"
                              placeholder="E.g.,&#10;John&#10;Sarah&#10;Group 1&#10;Topic A&#10;5">
John
Sarah
Michael
Emily
Group 1
Group 2
Topic A
Topic B
</textarea>

                    <!-- Probability Display -->
                    <div id="probabilityDisplayContainer" class="w-1/3 p-3 bg-gray-50 border border-gray-300 rounded-lg">
                        <p class="text-xs font-semibold text-gray-600 mb-1 border-b pb-1">Probabilities</p>
                        <div id="probabilityList" class="text-sm font-mono text-gray-800">
                            <!-- Content generated by JS -->
                        </div>
                    </div>
                </div>

                <button id="updateButton"
                        class="mt-4 w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md">
                    Update Wheel
                </button>

                <p class="text-sm text-gray-500 mt-4 italic">
                    <strong class="font-bold">Tip:</strong> Click "Update Wheel" whenever you change the list.
                </p>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration & Initialization ---

        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const inputList = document.getElementById('inputList');
        const updateButton = document.getElementById('updateButton');
        const spinButton = document.getElementById('spinButton');
        const resultBox = document.getElementById('resultBox');
        const messageBox = document.getElementById('messageBox');

        // CONSTANTS
        const MAX_ITEMS = 50;
        const totalSpins = 10; // Number of full spins the wheel will make

        // Initial state
        let items = [];
        let spinAngle = 0; // Current total rotation angle of the wheel (in radians)
        let isSpinning = false;

        // A vibrant and clean color palette for the segments
        const colorPalette = [
            '#4f46e5', // Indigo 600
            '#10b981', // Emerald 500
            '#f59e0b', // Amber 500
            '#ef4444', // Red 500
            '#6366f1', // Indigo 500
            '#34d399', // Emerald 400
            '#fcd34d', // Amber 300
            '#f87171', // Red 400
            '#8b5cf6', // Violet 500
            '#22d3ee', // Cyan 400
        ];

        // --- Core Functions ---

        /**
         * Displays a temporary message in the dedicated box.
         * @param {string} message The message to display.
         * @param {string} type 'error' or 'success'
         */
        function showMessage(message, type = 'error') {
            if (message) {
                messageBox.textContent = message;
                messageBox.classList.remove('hidden', 'bg-red-100', 'bg-green-100', 'text-red-700', 'text-green-700');
                if (type === 'error') {
                    messageBox.classList.add('bg-red-100', 'text-red-700');
                    messageBox.classList.remove('bg-green-100', 'text-green-700');
                } else {
                    messageBox.classList.add('bg-green-100', 'text-green-700');
                    messageBox.classList.remove('bg-red-100', 'text-red-700');
                }
            } else {
                messageBox.classList.add('hidden');
            }
        }
        
        /**
         * Converts user input text into an array of items and initializes the wheel.
         */
        function initializeItems() {
            // 1. Filter out empty lines and trim whitespace
            const newItems = inputList.value.split('\n').map(item => item.trim()).filter(item => item.length > 0);
            
            // 2. Check item limit
            if (newItems.length > MAX_ITEMS) {
                showMessage(`You have ${newItems.length} items. Please reduce the list to ${MAX_ITEMS} or fewer.`, 'error');
                spinButton.disabled = true;
                return;
            }

            items = newItems;
            drawWheel();
            showMessage(''); // Clear any previous messages

            // --- New Probability Calculation and Display ---
            const probabilityListDiv = document.getElementById('probabilityList');
            const probabilityContainer = document.getElementById('probabilityDisplayContainer');
            
            if (items.length > 0) {
                // Calculate the height of the textarea and apply it to the probability container
                // This ensures the two elements are visually aligned and scrolling together.
                const textareaHeight = inputList.clientHeight;
                probabilityContainer.style.height = `${textareaHeight}px`;
                probabilityContainer.classList.add('overflow-y-scroll'); // Enable scrolling

                const probPerItem = (100 / items.length).toFixed(2);
                let probabilityHtml = '';
                
                // We use a small placeholder div height to align percentages with text lines
                items.forEach((item, index) => {
                    // The 'h-[31px]' class roughly matches the height of one line in the textarea
                    probabilityHtml += `<div class="h-[31px] flex items-center"><p class="truncate">${probPerItem}%</p></div>`;
                });

                probabilityListDiv.innerHTML = probabilityHtml;
                

            } else {
                probabilityContainer.style.height = 'auto'; // Reset height
                probabilityContainer.classList.remove('overflow-y-scroll');
                probabilityListDiv.innerHTML = '<p class="text-gray-500 italic">No items added.</p>';
            }
        }


        /**
         * Draws the spinning wheel segments and text on the canvas.
         */
        function drawWheel() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.95; // 95% of the half-size for padding

            if (items.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#e5e7eb';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = '#6b7280';
                ctx.font = "24px Inter";
                ctx.textAlign = "center";
                ctx.fillText("Add Items Above", centerX, centerY);
                spinButton.disabled = true;
                return;
            }

            spinButton.disabled = isSpinning;

            const numSegments = items.length;
            const segmentAngle = (2 * Math.PI) / numSegments;

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save the context state (including the initial transform)
            ctx.save();
            // Move to the center of the canvas
            ctx.translate(centerX, centerY);
            // Apply the current rotation angle (spinAngle is the total clockwise rotation)
            ctx.rotate(spinAngle); 

            // Draw segments
            for (let i = 0; i < numSegments; i++) {
                const startAngle = i * segmentAngle;
                const endAngle = (i + 1) * segmentAngle;

                // Draw the segment
                ctx.beginPath();
                ctx.moveTo(0, 0);
                // Canvas arc method draws segments clockwise when endAngle > startAngle
                ctx.arc(0, 0, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = colorPalette[i % colorPalette.length];
                ctx.fill();

                // Draw segment borders
                ctx.strokeStyle = '#ffffff'; // White border between segments
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw text (rotated)
                ctx.save();
                // Position the text in the middle of the segment
                const textAngle = startAngle + segmentAngle / 2;
                ctx.rotate(textAngle);
                ctx.fillStyle = 'white';
                
                // Adjust font size based on segment size, capped at 20px for large segments.
                const maxSegmentRatio = (2 * Math.PI / numSegments) / (2 * Math.PI / 8); 
                const fontSize = Math.min(20, Math.max(10, 20 * maxSegmentRatio));
                
                ctx.font = `${fontSize}px Inter, sans-serif`;
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";

                // Text position: 85% out from the center
                const textX = radius * 0.85;
                const textY = 0;

                // Handle text wrapping/clipping for long names
                const maxTextWidth = radius * 0.5; 
                const itemText = items[i];

                // If text is too long, truncate and add ellipsis
                let displayedText = itemText;
                if (ctx.measureText(itemText).width > maxTextWidth) {
                    let tempText = '';
                    for (const char of itemText) {
                        const newText = tempText + char;
                        if (ctx.measureText(newText + '...').width < maxTextWidth) {
                            tempText = newText;
                        } else {
                            break;
                        }
                    }
                    displayedText = tempText.trim() + '...';
                }

                ctx.fillText(displayedText, textX, textY);
                ctx.restore();
            }

            // Draw the center circle (hub)
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.1, 0, 2 * Math.PI);
            ctx.fillStyle = '#374151'; // Dark gray hub
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Restore the context to remove the translation and rotation for the next draw cycle
            ctx.restore();
        }

        /**
         * Calculates the final stop angle and starts the spin animation.
         */
        function spinWheel() {
            if (isSpinning || items.length === 0) {
                if (items.length === 0) {
                    showMessage(`Please enter between 1 and ${MAX_ITEMS} items and click "Update Wheel".`, 'error');
                }
                return;
            }

            isSpinning = true;
            spinButton.disabled = true;
            resultBox.textContent = 'Spinning...';
            showMessage('');

            const numSegments = items.length;
            const segmentAngle = (2 * Math.PI) / numSegments;

            // 1. Determine the winning index (where the pointer points when spin stops)
            const winningIndex = Math.floor(Math.random() * numSegments);

            // 2. Calculate the required rotation angle (stopOffset) for the winning index.
            // Canvas coordinates: 0 radians is 3 o'clock.
            
            // Angle of the middle of the winning segment (M, relative to 3 o'clock)
            const targetSegmentMidAngle = winningIndex * segmentAngle + segmentAngle / 2;

            // Target pointer position (P) is 12 o'clock (PI / 2 radians). 
            // We use PI/2 for the calculation target to counteract the 180-degree visual offset 
            // and align the winner correctly with the 6 o'clock pointer position.
            const pointerTargetAngle = Math.PI / 2; 

            // The required clockwise rotation (R) to move the center of M to P is: R = P - M (normalized).
            let rawOffset = pointerTargetAngle - targetSegmentMidAngle;

            // Normalize rawOffset to a positive angle between 0 and 2*PI.
            let stopOffset = (rawOffset % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);

            // 3. Calculate the total required rotation angle (Full Spins + Stop Offset)
            const fullRotation = totalSpins * 2 * Math.PI;
            const totalTargetAngle = fullRotation + stopOffset; // This guarantees precision!

            // Start the animation loop
            const startTime = Date.now();
            // Duration of the spin (in milliseconds)
            const spinDuration = 5000;

            function animateSpin() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / spinDuration, 1);

                // Use an easing function (e.g., cubic ease-out) for deceleration
                const easedProgress = 1 - Math.pow(1 - progress, 3); // Slows down towards the end

                // Update the global spinAngle state based on progress
                spinAngle = totalTargetAngle * easedProgress;

                drawWheel();

                if (progress < 1) {
                    requestAnimationFrame(animateSpin);
                } else {
                    // Animation finished
                    isSpinning = false;
                    spinButton.disabled = false;
                    // The winner is determined by the pre-calculated winningIndex
                    const winner = items[winningIndex];
                    
                    resultBox.textContent = winner;
                    resultBox.classList.add('bg-yellow-100', 'text-yellow-800', 'shadow-xl');
                    setTimeout(() => {
                        resultBox.classList.remove('bg-yellow-100', 'text-yellow-800', 'shadow-xl');
                        resultBox.classList.add('bg-indigo-50', 'text-indigo-700', 'shadow-inner');
                    }, 3000);
                    showMessage(`The winner is: ${winner}!`, 'success');
                }
            }

            // Start the first frame
            animateSpin();
        }

        // --- Event Listeners ---

        updateButton.addEventListener('click', () => {
            if (!isSpinning) {
                initializeItems();
                if (items.length > 0) {
                    resultBox.textContent = 'Wheel Updated!';
                }
            }
        });

        // Event listener to synchronize scrolling between textarea and probability list
        inputList.addEventListener('scroll', () => {
            const probabilityContainer = document.getElementById('probabilityDisplayContainer');
            probabilityContainer.scrollTop = inputList.scrollTop;
        });

        spinButton.addEventListener('click', spinWheel);

        // --- Initial Setup on Load ---

        // Function to ensure canvas scales responsively
        function resizeCanvas() {
            const container = document.getElementById('wheelContainer');
            // Set both the CSS size and the internal canvas resolution
            canvas.width = 500; // Fixed resolution for high quality drawing
            canvas.height = 500;
            // The CSS takes care of the scaling in the container
            drawWheel();
        }

        window.addEventListener('resize', resizeCanvas);
        
        // Initial setup
        initializeItems();
        resizeCanvas();

    </script>
</body>
</html>
